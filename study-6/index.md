#### 10장
데드락이 발생하면?
DATABASE: 특정 트랜잭션을 종료 시키고, 남은 트랜잭션이 작업 수행
APPLICATION: 재시작

원인
 - 동적인 락 순서에 의한 데드락
   ```text
        A -> left 락 확보 -> right 락 확보 대기 -> 대기 
        B -> right 락 확보 -> left 락 확보 대기 -> 대기
    ```

 - 객체 간의 데드락: synchronized 사용된 메서드를 서로 다른 클래스에서 호출하면
   두개의 스레드에서 두개의 락을 서로 다른 순서로 가져가는 상황 발생
  
- 리소스 데드락
  - 두 개의 데이터베이스에 대한 연결의 경우가 적절한 예시가 된다

데드락 방지 기법
- 캡슐화
- 락을 확보하는 순서를 지정
- 오픈 호출: 락을 확보하지 않은 상태에서 메서드 호출
- 락의 시간 제한(Lock 클래스 -> tryLock() 사용)

원인분석: 스레드 덤프를 활용

그 밖에 문제점
- 소모(starvation)
  - 스레드가 작업을 진행하는데 필요한 자원을 할당받지 못하는 경우
- 응답속도 저하
- 라이브락
  - 특정 작업의 결과를 받아야 다음으로 넘어가지만 계속 실패 후 재시도하는 경우

#### 11장
```text
성능: 특정 작업을 얼마나 빠르게 처리하는가 또는 자원이 주어지는 경우  
얼마나 많은 양의 작업을 수행하는지를 통하여 파악  

확장성(scalability): cpu, 메모리, 디스트, I/O 처리 장치 등의 추가적인 장비를 사용  
처리량이나 용량을 얼마나 쉽게 키울 수 있는지를 의미한다.
```  
서버 어플리케이션을 만들 때 고려사항  
> 성능측며넹서 얼마나 빠르게보다 얼마나 많이(확장성 및 처리량 / 용량)가 더 중요하다

성능 트레이드 오프
> 코드의 가독성 및 유지보수의 용이함 보다는 최적화에 초점  
> 최적화를 추구하다 보면 병렬 프로그래밍에서 오류를 범하기 쉬워진다

암달의 법칙(Amdahl's law)  
> 병렬작업과 순차작업의 비율에 따라 하드웨어 자원을 추가투입 할 떄 속도향상 예측치 계산  
> 순차처리 작업이 증가할 때 속도감소가 얼만큼 일어나는지 예측가능

[x] 모든 병렬 프로그램에서는 항상 순차적으로 실행돼야만 하는 부분이 존재

스레드와 비용
> 컨텍스트 스위칭

> 메모리 동기화
>> 경쟁 조건이 발생하는 동기화 블록 최적화에 대한 고민이 필요

> 블로킹

> 락 경쟁 줄이기
>> 병렬 어플리케이션 확장성에 가장 큰 위협은 자원독점 락이다  
>> 다음과 같은 방법을 고려해 볼 수 있다  
>>    - 락 확보 후 유지시간 절감(e.g., 락 구역 좁히기)
>>    - 락 확보 요청 횟수 절감
>>    - 독점적인 락 대신 병렬성을 높이는 조율 방법 선택(e.g., 락 분할 or 락 스트라이핑)  

> 핫 필드 최소화
>> 락을 세밀하게 나누어도 모든 연산에 필요한 변수가 있다면 확장성이 떨어지며 이를 핫 필드라고 한다
>> 이를 구현한 좋은 예시로 ConcurrentHashMap 클래스가 있다
>> - 락으로 분배된 각 부분마다 카운터 변수를 따로 관리한다.

